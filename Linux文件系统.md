# 4、探究文件系统

## 4.1 ls

除了使用 `ls`能列出当前目录所有文件和子目录的列表，还可以指定别的目录。如 `ls /usr`

甚至可以列出多个指定目录的内容 如 `ls ~ /usr`，表示列出家目录和 ‘/usr’目录

我们可以改变输出格式，来得到更多的细节。

使用`ls`的`-l`选项，则结果以长模式输出

![image-20230328095514935](D:\笔记\Linux\assets\image-20230328095514935.png)

## 4.2选项和参数

命令行经常会带有一个或多个用来更正命令行为的选项，更进一步，选项后面会带有一个或多个参数，这些参数是命令作用的对象。所以大多数命令看起来像这样：

```shell
command -options argument
```

大多数命令使用的选项，是有一个中划线加上一个字符组成，例如 “-l”，但是，许多命令也支持长选项，长选项由两个中划线加上一个子组成，也有许多命令允许把多个短选项串在一起使用。

```shell
# l选像表示按照长格式输出 t表示按文件修改时间的先后顺序来排序
ls -lt

# 加上长选项 --reverse，结果将以相反的顺序输出
ls -lt --reverse
```

`ls`有大量的选项，下面表中列出常用选项

![image-20230328100041282](D:\笔记\Linux\assets\image-20230328100041282.png)

## 4.3深入研究长格式输出

我们直到，`-l`选项导致ls的输出结果以长格式输出，这种格式包含大量的可用信息。

![image-20230328100200643](D:\笔记\Linux\assets\image-20230328100200643.png)

下面的表是在`ubuntu`中同样的命令，各个输出字段的含义

![image-20230328100229091](D:\笔记\Linux\assets\image-20230328100229091.png)

## 4.4确定文件类型

知道文件包含的内容是很有用的，我们将用 `file`命令来确定文件的类型。

```shell
file filename
```

当调用`file`命令后，`file`命令会打印出文件内容的简单描述。

在Linux中，**一切皆文件**。

## 4.5用less浏览文件内容

`less`命令是一个用来浏览文本文件的程序。总管Linux系统，有许多人类可读的文本文件，`less`程序为我们检查文本文件提供了方便。

> 什么是“文本” 在计算机中，有许多方法可以表达信息。所有的方法都涉及到，在信息与一些数 字之间确立一种关系，而这些数字可以用来代表信息。毕竟，计算机只能理解数字， 这样所有的数据都被转换成数值来表示。 有些数值表达法非常复杂（例如压缩的视频文件），而其它的就相当简单。最早 也是最简单的一种表达法，叫做 ASCII 文本。ASCII（发音是 “As-Key”）是美国信 息交换标准码的简称。这是一个简单的编码方法，它首先被用在电传打字机上，用 来实现键盘字符到数字的映射。 文本是简单的字符与数字之间的一对一映射。它非常紧凑。五十个字符的文本 翻译成五十个字节的数据。文本只是包含简单的字符到数字的映射，理解这点很重 要。它和一些文字处理器文档不一样，比如说由微软或 OpenOffice.org 文档编辑器创建的文件。这些文件，和简单的 ASCII 文件形成鲜明对比，它们包含许多非文本 元素，来描述它的结构和格式。纯 ASCII 文件只包含字符本身，和一些基本的控制 符，像制表符、回车符及换行符。纵观 Linux 系统，许多文件以文本格式存储，也 有许多 Linux 工具来处理文本文件。甚至 Windows 也承认这种文件格式的重要性。 著名的 NOTEPAD.EXE 程序就是一个纯 ASCII 文本文件编辑器。

为什么我们要查看文本文件？因为许多包含系统配置的文件（配置文件），是以文本格式存储的。另外，许多系统所用到的实际程序（叫做脚本）也是以这种格式存储的。

```shell
less filename
```

一旦运行，`less`程序允许你前后滚动文件。例如，要查看一个定义了系统中全部用户身份的文件，输入以下命令：

```shell
less /etc/passwd
```

按下 `q`键，退出程序

下面是`less`常用键盘命令

![image-20230328104929532](D:\笔记\Linux\assets\image-20230328104929532.png)

![image-20230328104938377](D:\笔记\Linux\assets\image-20230328104938377.png)

`less`就是 `more`，`less`属于页面调度器类程序，这些程序允许以逐页方式轻松浏览长文本文档，`more`只能向前翻页，`less`允许前后翻页。

## 4.7旅游指南

常用浏览的目录：

| 目录           | 评论                                                         |
| -------------- | ------------------------------------------------------------ |
| /              | 根目录，万物起源                                             |
| /bin           | 包含系统启动和运行所必须的二进制程序                         |
| /boot          | 包含Linux内核、初始RAM磁盘映像（用于启动时所需的驱动）和启动加载程序。<br />有趣的文件：<br />`/boot/grub/grub.conf or menu.lst`被用来配置启动加载程序<br />`/boot/vmlinuz` Linux内核 |
| /dev           | 这是一个包含设备节点的特殊目录。“一切皆文件”也适用于设备。在这个目录中，内核维护者所有设备的列表 |
| /etc           | 这个目录包含所有系统层面的配置文件。他也包含一系列的shell脚本，在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是刻度的文本文件，列举一些有趣的文件：<br />`/etc/crontab`定义自动运行的任务<br />`/etc/fstab`包含存储设备的列表，以及与他们相关的挂载点<br />`/etc/passwd`包含用户账号列表 |
| /home          | 在通常的配置环境下，系统会在 `/home`下，给每个用户分配一个目录。普通用户只能在自己的目录下写文件。这个限制保护系统免受错误地用户活动破坏 |
| /lib           | 包含核心系统程序所使用的共享库文件。这些文件与Windows中的动态链接库相似 |
| /lost+found    | 每个使用Linux文件系统的格式化分区或设备，例如ext3文件系统，都会有这个目录，当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统真正的损坏了 |
| /media         | 在现在的Linux系统中，`/media`目录会包含可移动介质的挂载点，例如USB驱动器，CD-ROMs等。这些介质连接到计算机之后，会自动地挂载到这个目录节点下。 |
| /mnt           | 在早些的Linux系统中，`/mnt`目录包含可移动介质的挂载点        |
| /opt           | 在这 `/opt`目录用来安装可选的软件，主要用来存储可能安装在系统中的商业软件产品 |
| /proc          | 这个 `/proc`很特殊。从存储在硬盘上的文件的意义来说，它不是真正地文件系统。相反，他是一个由Linux内核维护的虚拟文件系统。它所包含的文件是内核地窥视孔。这些文件是可读的，他们会告诉你内核是怎么监管计算机地。 |
| /root          | root账户的家目录                                             |
| /sbin          | 这个目录包含系统二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留 |
| /tmp           | 这个 `/tmp`目录，是用来存储各种程序创建的临时文件的地方。一些配置导致系统每次重新启动时，都会清空这个目录。 |
| /usr           | 在Linux系统中，`/usr`目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 |
| /usr/bin       | `/usr/bin`目录包含系统安装的可执行程序。通常，这个目录会包含许多程序 |
| /usr/lib       | 包含由 `/usr/bin`目录中的程序所用的共享库                    |
| /usr/local     | 这个 `/usr/local`目录，是非系统发行版自带程序的安装目录。通常，由源码编译的程序会安装在 `/usr/local/bin`目录下。新安装的Linux系统中会存在这个目录，并且在管理员安装程序之前，这个目录是空的。 |
| /usr/sbin      | 包含许多系统管理程序                                         |
| /usr/share     | `/usr/share`目录包含许多由 `/usr/bin`目录中的程序使用的共享数据。其中包含像默认的配置文件、图标、桌面背景、音频文件等。 |
| /usr/share/doc | 大多数安装在系统中的软件包含一些文档。在 `/usr/share/doc`目录下，我们可以找到按照软件包分类的文档。 |
| /var           | 除了 `/tmp`和 `/home`目录之外，相对来说，目前我们看奥的目录是静态的，就是说，它们的内容不会改变。`/var`目录存放的是动态文件。各种数据库，假脱机文件，用户邮件等，都位于在这里。 |
| /var/log       | 这个 `/var/log`目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且应该实时监测它们。其中最重要的文件是 `/var/log/message`。注意，为了系统安全，在一些系统中，必须是超级管理员才能查看这些日志文件。 |
|                |                                                              |

## 4.8符号链接

在我们到处看的时候，可能会看到一个目录，列出像这样的一条信息：

> lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -> libc-2.6.so

这是一个特殊文件，叫做 **符号链接**或者是 **软链接**。

下一章节详细说明

## 4.9硬链接

硬链接同样允许文件有多个名字，但是硬链接以不同的方法来创建多个文件名。

# 5、操作文件和目录

- `cp`--复制文件和目录
- `mv`--移动/重命名文件和目录
- `mkdir`--创建目录
- `rm`--删除文件和目录
- `ln`--创建硬链接和符号链接

这五个命令是最常使用的Linux命令之列。他们用来操作文件和目录。

## 5.1通配符

shell提供了特殊字符来帮助你快速指定一组文件名，这些特殊字符叫做通配符。

使用通配符允许你根据字符的组合模式来选择文件名。

![image-20230328113617566](D:\笔记\Linux\assets\image-20230328113617566.png)

最长使用的字符类：

![image-20230328113634537](D:\笔记\Linux\assets\image-20230328113634537.png)

借助通配符，为文件名构建非常复杂的选择标准成为可能。下面是一些类型匹配的范例：

![image-20230328113732094](D:\笔记\Linux\assets\image-20230328113732094.png)

![image-20230328113742468](D:\笔记\Linux\assets\image-20230328113742468.png)

> 字符范围 如果你用过别的类 Unix 系统的操作环境，或者是读过这方面的书籍，你可能遇 到过 [A-Z] 或 [a-z] 形式的字符范围表示法。这些都是传统的 Unix 表示法，并且在 早期的 Linux 版本中仍有效。虽然它们仍然起作用，但是你必须小心地使用它们， 因为它们不会产生你期望的输出结果，除非你合理地配置它们。从现在开始，你应 该避免使用它们，并且用字符类来代替它们。 通配符在 GUI 中也有效 通配符非常重要，不仅因为它们经常用在命令行中，而且一些图形文件管理器也 支持它们。 • 在 Nautilus (GNOME 文件管理器）中，可以通过 Edit/Select 模式菜单项来 选择文件。输入一个用通配符表示的文件选择模式后，那么当前所浏览的目录 中，所匹配的文件名就会高亮显示。 • 在 Dolphin 和 Konqueror（KDE 文件管理器）中，可以在地址栏中直接输入 通配符。例如，如果你想查看目录 /usr/bin 中，所有以小写字母 ‘u’ 开头的文 件，在地址栏中敲入 ‘/usr/bin/u*‘，则文件管理器会显示匹配的结果。 最初源于命令行界面中的想法，在图形界面中也适用。这就是使 Linux 桌面系 统如此强大的众多原因中的一个

## 5.2 mkdir - 创建目录

```shell
mkdir directory...
```

若是 `mkdir dir1`则会创建一个目录

为 `mkdir dir1 dir2 dir3`则会创建三个目录

## 5.3 cp - 复制文件和目录

cp 命令，复制文件或者目录。它有两种使用方法：

```shell
# 复制单个文件或目录 item1 到文件或目录 item2
cp item1 item2
```

```shell
# 复制多个项目（文件或目录）到一个目录下
cp item... directory
```

### 5.3.1有用的选项和实例

这里列举了 cp 命令一些有用的选项（短选项和等效的长选项）：

![image-20230328114435393](D:\笔记\Linux\assets\image-20230328114435393.png)

![image-20230328114444051](D:\笔记\Linux\assets\image-20230328114444051.png)

cp 实例

| 命令                  | 运行结果                                                     |
| --------------------- | ------------------------------------------------------------ |
| `cp file1 file2`      | 复制文件file1内容到文件file2.如果file2已经存在，file2的内容会被file1的内容重写。如果file2不存在，则会创建file2 |
| `cp -i file1 file2`   | 和上面一样，除了如果file2存在的话，在文件file2被重写之前，会提示用户确认信息 |
| `cp file1 file2 dir1` | 复制文件file1和文件file2到目录dir1.目录dir1必须存在          |
| `cp dir1/* dir2`      | 使用一个通配符，在目录dir1中的所有文件都被复制到目录dir2中。dir2必须存在 |
| `cp -r dir1 dir2`     | 复制目录dir1中的内容到目录dir2.如果目录dir2不存在，创建目录dir2，操作完成后，目录dir2中的内容和dir1中的一样。如果dir2存在，则目录dir1（包括内容）将会被复制到dir2中 |

## 5.4 mv - 移动和重命名文件

mv 命令可以执行文件移动和文件命名任务，这依赖于你怎样使用它。任何一种情况下，完成操作之后，原来的文件名不再存在。mv 使用方法和 cp 很相像。

```shell
# 把文件或目录 item1 移动或重命名为 item2
mv item1 item2
```

```shell
# 把一个或多个条目从一个目录移动到另一个目录
mv item... directory
```

### 5.4.1 有用的选项和实例

![image-20230328115319118](D:\笔记\Linux\assets\image-20230328115319118.png)

mv 实例：

| 命令                  | 运行结果                                                     |
| --------------------- | ------------------------------------------------------------ |
| `mv file1 file2`      | 移动文件file1内容到文件file2.如果file2已经存在，file2的内容会被file1的内容重写。如果file2不存在，则会创建file2。这两种情况下，file1都不再存在。 |
| `mv -i file1 file2`   | 和上面一样，除了如果file2存在的话，在文件file2被重写之前，会提示用户确认信息 |
| `mv file1 file2 dir1` | 移动文件file1和文件file2到目录dir1.目录dir1必须存在          |
| `mv dir1 dir2`        | 移动目录dir1中的内容到目录dir2.如果目录dir2不存在，创建目录dir2，操作完成后，目录dir2中的内容和dir1中的一样。如果dir2存在，则目录dir1（包括内容）将会被复制到dir2中 |

## 5.5 rm - 删除文件和目录

rm 命令用来移除文件和目录

```shell
# 表示删除一个或多个文件或目录
rm item...
```

### 5.5.1有用的选项和实例

![image-20230328115653659](D:\笔记\Linux\assets\image-20230328115653659.png)

| 命令                | 运行结果                                                     |
| ------------------- | ------------------------------------------------------------ |
| `rm file1`          | 默默地删除文件                                               |
| `rm -i file1`       | 在删除文件之前需要提示用户确认信息                           |
| `rm -r file1 dir1`  | 删除文件file1，目录dir1，及dir1中的内容                      |
| `rm -rf file1 dir1` | 同上，除了如果文件file1，或目录dir1不存在的话，rm仍会继续执行 |

> 小心 rm ！没有复原命令！

## 5.6 ln - 创建链接

ln 命令即可创建硬链接，也可以创建符号链接。可用其中一种方法来使用它

```shell
# 创建硬链接
ln file link
```

```shell
# 创建软连接 item 可以是一个文件或者是一个目录
ln -s item link
```

### 5.6.1 硬链接

与更加现代的符号链接相比，硬链接是最初Unix创建链接的方式。每个文件默认会有一个硬链接，这个硬链接，这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目录项。

硬链接有两个重要局限性：

1. 一个硬链接不能关联他所在文件系统之外的文件。这是说一个链接不能关联与链接本身不在同一个磁盘分区上的文件。
2. 一个硬链接不能关联一个目录。

一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录内容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文件的链接都删除掉。知道硬链接很重要，因为你可能有时会遇到它们，但现在实际中更喜欢使用符号链接。

### 5.6.2 符号链接

创建符号链接是为了客服硬链接的局限性。符号链接生效，是通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。在这一方面，它们和Windows的快捷方式差不多，当然，符号链接早于Windows快捷方式很多年。

一个符号链接指向一个文件，而且这个符号链接本身与其他的符号链接几乎没有区别。例如，如果你忘一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当你删除一个符号链接时，只有这个链接被删除，而不是文件本身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中，ls命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。

## 5.7创建游戏场（实战演习）

下面我们将要做一些真正的文件操作，让我们先建立一个安全地带，来玩一个文件操作命令。首先我们需要一个工作目录。在我们的家目录下创建一个叫做 “playground” 的目录。

### 5.7.1 创建目录

> 首先在家目录下创建一个 `playground`目录

```shell
# 进入家目录
cd 

# 创建 playground 目录
mkdir playground
```

> 在 `playground`目录下创建一堆目录，分别为 `dir1`和 `dir2`

```shell
# 进入 playground 目录
cd playground

# 创建目录
mkdir dir1 dir2
```

> 下面我们使用 `cp` 命令从 `/etc`目录赋值到 `passwd`文件到当前工作目录下

```shell
# 这里使用 . 来简化当前目录的写法
cp /etc/passwd .
```

> 使用 `ls -l`查看当前目录

```shell
ls -l
```

> 现在，可以使用 `-v`选项，看看 `cp` 命令做了些什么

```shell
cp -v /etc/passwd .
```

> 还可以使用 `cp -i /etc/passwd`命令再操作一遍，如果输入y，则文件重写，输入n，则什么都不变

### 5.7.2 移动和重命名文件

> 现在，“passwd” 这个名字，看起来不怎么有趣，所以我们可以改一个名字：

```shell
mv passwd fun
```

> 让我们来传送一下fun文件，通过移动重命名的文件到各个子目录，然后再把它移回到当前目录：

```shell
# 移动 fun 到 dir1 中
mv fun dir1

# 再把 fun 移到 dir2 中
mv /dir1/fun dir2

# 最后把 fun 移回到 工作目录中
mv dir2/fun .
```

注意：在移动的过程中，我们可以通过 `ls -l`来查看过程。

### 5.7.3创建硬链接

> 现在我们试着创建链接/首先是硬链接。我们创建一些关联我们数据文件的链接：

```shell
ln fun fun-hard

ln fun dir1/fun-hard

ln fun dir2/fun-hard
```

> 现在我们有四个文件的实例，可以看一下 playground 中的内容

![image-20230328133018082](D:\笔记\Linux\assets\image-20230328133018082.png)

这里我们注意到，文件 `fun` 和 `fun-hard` 的第二个字段是4，这个数字是文件 `fun`的硬链接数目。你要记得一个文件至少有一个硬链接没因为文件名就是由链接创建的。那么，我们怎样知道实际上fun和fun-hard是同一个文件呢？在这里，`ls`不是很有用，虽然我们能看到两个文件大小相同（第五个字段），但是并没有提供更确定的消息证明文件是同一个。

当考虑到硬链接的时候，我们可以假设文件由两部分组成：**包含文件内容的数据部分**和**持有文件名的名字部分**，这将有助于我们理解这个概念。当我们创建文件硬链接的时候，实际上是为文件创建了额外的名字部分，并且这些名字都关联到相同的数据部分。这时系统会分配一连串的磁盘块给所谓的索引节点，然后索引节点与文件名字部分相关联。因此每一个硬链接都关系到一个具体的包含文件内容的索引节点。

> `ls`命令有一种方法，来展示（文件索引节点）的信息。在命令中加上 `-i` 选项：

```shell
ls -li
```

![image-20230328133953260](D:\笔记\Linux\assets\image-20230328133953260.png)

这里可以看到，两个文件的索引节点号是一样的，所以这是同一个文件

### 5.7.4 创建符号链接

建立符号链接的目的是为了克服硬链接的两个缺点：硬链接不能跨越物理设备，硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向目标文件或目录的文本指针。

> 符号链接的建立过程相似于创建硬链接

```shell
ln -s fun fun-sym

ln -s ../fun dir1/fun-sym

ln -s ../fun dir2/fun-sym
```

第一条指令相当直接，只需要加上 `-s` 即可创建，不是一个硬链接。下面两条又是什么意思呢？记住，当我们创建一个符号链接的时候，会建立一个目标文件在哪里和符号链接有关联的文本描述。如果我们看看 `ls` 命令的输出结果，比较容易理解：

![image-20230328134909478](D:\笔记\Linux\assets\image-20230328134909478.png)

目录 `dir1` 中，`fun-sym`的列表说明了他是一个符号链接，通过在第一字段中的首字符 “1”可知，并且他还指向 “../fun”，也是正确的。相对于 `fun-sym` 的存储位置，fun在它的上一个目录。同时注意，符号链接文件的长度是6，这是字符串 “../fun” 所包含的字符数，而不是符号链接所指向的文件长度。

当建立符号链接时，能使用绝对路径也能使用相对路径，绝对路径如下：

```shell
ln -s /home/poison02/playground/fun dir1/fun-sym
```

很明显，使用相对路径更加简洁。

除了普通文件，符号链接也能关联目录：

```shell
ln -s dir1 dir1-sym
```

### 5.7.5 移动文件和目录

正如我们之前讨论的，rm 命令被用来删除文件和目录。我们将要使用它来清理一下我们的游戏场。首先，删除一个硬链接：

```shell
rm fun-hard

ls -l
```

![image-20230328145401679](D:\笔记\Linux\assets\image-20230328145401679.png)

结果不出所料。文件 `fun-hard` 消失了，文件 `fun`的链接数从4减到3，正如目录列表第二个字段所示。

接下来，仅为了娱乐，我们将删除 `fun` 文件：

```shell
rm -i fun

ls -l
```

![image-20230328145643643](D:\笔记\Linux\assets\image-20230328145643643.png)

可以看到，因为 `fun` 文件被删除了，所以软链接指向了不存在的文件，链接也坏了。

如果我们试着使用损坏的链接：

```shell
less fun-sym
```

![image-20230328145818844](D:\笔记\Linux\assets\image-20230328145818844.png)

现在我们删除符号链接：

```shell
rm fun-sym dir1-sym

ls -l
```

![image-20230328145925781](D:\笔记\Linux\assets\image-20230328145925781.png)

对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。而rm命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。

最后，我们将删除我们的游戏场。为了完成这项工作，我们将返回到我们的家目录，然后用 `rm`命令加上 `-r`选项，来删除 `playground`和目录下的所有内容，包括子目录。

```shell
cd

rm -r playground
```

![image-20230328150223125](D:\笔记\Linux\assets\image-20230328150223125.png)

> 用 GUI 来创建符号链接 文件管理器 GNOME 和 KDE 都提供了一个简单而且自动化的方法来创建符号 链接。在 GNOME 里面，当拖动文件时，同时按下 Ctrl+Shift 按键会创建一个链 接，而不是复制（或移动）文件。在 KDE 中，无论什么时候放下一个文件，会弹出 一个小菜单，这个菜单会提供复制，移动，或创建链接文件选项。